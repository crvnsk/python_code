################################################## 1. Python: Привет, Мир!
print('Hello, World!')

################################################## 2. Python: Комментарии   
#print('I am the King') # For Lannisters!
# For Winterfell!
# For Lanisters!

################################################## 3. Python: Инструкции (Statements)
# Задание
# Выведите на экран друг за другом три имени: Robert, Stannis, Renly. В результате на экране должно отобразиться:
# Robert
# Stannis
# Renly
# print ('Robert')
# print ('Stannis')
# print ('Renly')

################################################## 4. Python: Как мы проверяем ваши решения
# AssertionError: '10' != '35'
# Разработка через тестирование
# Разработка через тестирование (англ. test-driven development, TDD) — техника разработки программного обеспечения, 
# которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий 
# желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг нового кода 
# к соответствующим стандартам.

################################################## 5. Python: Синтаксические ошибки
# print('Hodor)
# $ python index.py
# File "index.py", line 1
#   print('Hodor)
#               ^
# SyntaxError: EOL while scanning string literal


################################################## 6. Python: Арифметические операции
# Кроме сложения доступны следующие операции:
# - — вычитание
# * — умножение
# ** — возведение в степень
# / — деление
# // — целочисленное деление
# % — остаток от деления

################################################## 7. Python: Коммутативная операция
# «От перемены мест слагаемых сумма не меняется» — это один из базовых законов арифметики, который также называется 
# коммутативным законом. Бинарная операция считается коммутативной, если вы получаете тот же самый результат, 
# поменяв местами операнды

################################################## 8. Python: Композиция операций
# разберем пример: 2 * 4 * 5 * 10.
# Сначала вычисляется 2 * 4 и получается выражение 8 * 5 * 10
# Затем 8 * 5. В итоге имеем 40 * 10
# В итоге происходит последнее умножение, и получается результат 400

################################################## 9. Python: Приоритет
# «приоритет операции», например, математических действий

################################################## 10. Python: Числа с плавающей точкой
# что на это скажет Python:
# 0.2 + 0.1 # 0.30000000000000004
# важно понимать, что операции с плавающими числами неточны (эту точность можно регулировать), а значит при решении задач, 
# связанных с подобными числами, необходимо прибегать к специальным трюкам, которые позволяют добиться необходимой точности.

################################################## 11. Python: Линтер
# Python стандарт один — PEP8
# result = 1+ 3
# Линтер будет ругаться на нарушение правила: 
# E225 missing whitespace around operator. По стандарту, оператор + всегда должен отделяться пробелами от операндов.

################################################## 12. Python: Кавычки
# print('Dragon's mother')
# # SyntaxError: invalid syntax
# print("Dragon's mother")
# # Экранируем кавычки вокруг No, чтобы интерпретатор
# # распознал их как часть строки
# print("Dragon's mother said \"No\"")
# # => Dragon's mother said "No"
# print("\\")
# # => \
# Напишите программу, которая выведет на экран:
# "Khal Drogo's favorite word is "athjahakar""
# print ('"Khal Drogo\'s favorite word is "athjahakar\""')

################################################## 13. Python: Экранированные последовательности
# Экранированная последовательность — специальная комбинация символов в тексте. Например, \n — это перевод строки. 
# Такие последовательности еще называют управляющими конструкциями. 
# табуляция \t — разрыв, который получается при нажатии на кнопку Tab
# возврат каретки \r — работает только в Windows
# В коде последовательность \n выглядит как два символа, но с точки зрения интерпретатора — это один специальный символ
# Если нужно вывести \n как текст (два отдельных печатных символа), то можно воспользоваться экранированием — 
# добавить еще один \ в начале. Последовательность \\n отобразится как символы \ и n, которые идут друг за другом:
# print("Joffrey loves using \\n") # => Joffrey loves using \n
# Напишите программу, которая выводит на экран:
# - Did Joffrey agree?
# - He did. He also said "I love using \n".
# print ('- Did Joffrey agree?\n- He did. He also said "I love using \\n".')

################################################## 14. Python: Конкатенация
# Конкатенация — операция соединения двух строк. Например, print("King's " + ' Landing')

################################################## 15. Python: Кодировка
# Кодировка — набор символов, закодированных с помощью чисел для представления текста в электронном виде
# В Python можно «запросить» и вывести на экран любой символ из кодировки ASCII. 
# Для этого используется функция chr(). Например:
# https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html
# выведите на экран (каждый на своей собственной строке) ~, ^ и %.
# print(chr(126))
# print(chr(94))
# print(chr(37))

################################################## 16. Python: Что такое переменная
# Переменная — способ сохранить информацию и дать ей имя для последующего использования в коде.
# #Создайте переменную с именем motto и содержимым What Is Dead May Never Die!. 
# #Распечатайте содержимое переменной.
# motto = 'What Is Dead May Never Die!'
# print (motto)

################################################## 17. Python: Изменение переменной
# Переменная — способ сохранить информацию и дать ей имя для последующего использования в коде.
# # greeting - переводится как приветствие
# greeting = 'Father!'
# print(greeting)  # => Father!

# greeting = 'Mother!'
# print(greeting)  # => Mother!

################################################## 18. Python: Выбор имени переменной
# Важно придумать понятное название, которое отражает смысл переменной. При этом важно давать такие имена, которые будут понимать 
# без контекста, без изучения окружающего кода.
# Существует общепринятое правило: не используйте транслит для имен — только английский язык. 
# Если вы испытываете сложности с английским, # то пользуйтесь переводчиком. 
# Со временем, копаясь в чужом коде, вы научитесь правильно именовать переменные.

# Среди разработчиков есть шутка: «Названия переменных — это одна из самых сложных вещей в программировании». 
# Придумывать названия и правда сложно. Например, сложно назвать переменную, в которой хранится количество неоплаченных 
# заказов от клиентов с задолженностью в предыдущем квартале.
# Создайте переменную, описывающую количество своих братьев, и присвойте ей значение 2. 
# Распечатайте содержимое переменной. 
# Затем сравните свое имя с именем, которое используется в учительском решении.
# Решение учителя:
# my_brothers_count = 2

# print(my_brothers_count)
# Ваше решение:
# # Создайте переменную, описывающую количество своих братьев, и присвойте ей значение 2. 
# # Распечатайте содержимое переменной. 
# # Затем сравните свое имя с именем, которое используется в учительском решении.
# number_of_brothers = 2
# print(2)


################################################## 19. Python: Ошибки при работе с переменными
# exception NameError
# Возникает, когда локальное или глобальное имя не найдено. Это относится только к неполным именам.
# Связанное значение — это сообщение об ошибке, включающее имя, которое не удалось найти.
# Атрибут имени может быть установлен с помощью аргумента конструктора, состоящего только из ключевого слова.
# Когда он установлен, он представляет имя переменной, к которой пытались получить доступ.

################################################## 20. Python: Выражения в определениях
# С помощью переменных можно записывать еще более сложные вычисления. Вернемся к нашей валютной программе. 
# Запишем стоимость доллара в рублях, как отдельную переменную. Вычислим цену 50 евро в долларах, умножив их на 1.25. 
# Допустим, что 1 доллар — 60 рублей:

# rubles_per_dollar = 60
# dollars_count = 50 * 1.25  # 62.5
# rubles_count = dollars_count * rubles_per_dollar  # 3750.0

# print(rubles_count)
# Теперь добавим к выводу текст с помощью конкатенации:

# rubles_per_dollar = 60
# dollars_count = 50 * 1.25  # 62.5
# rubles_count = dollars_count * rubles_per_dollar  # 3750.0

# # Функция str() превращает число в строку.
# # О таких превращениях будет отдельный урок.
# print('The price is ' + str(rubles_count) + ' rubles')
# # => The price is 3750.0 rubles

################################################## 21. Python: Переменные и конкатенация
# Конкатенация — операция соединения двух строк. Например, console.log("King's " + ' Landing');
# Напишите программу, которая будет генерировать заголовок и тело письма, используя уже готовые переменные, 
# и выводить получившиеся строки на экран.

# Для заголовка используйте переменные first_name и greeting, запятую и восклицательный знак. 
# Выведите это на экран в правильном порядке.

# Для тела письма используйте переменные info и intro, при этом второе предложение должно быть на новой строке.

# Результат на экране будет выглядеть так:

# Hello, Joffrey!
# Here is important information about your account security.
# We couldn't verify your mother's maiden name.

# info = "We couldn't verify your mother's maiden name."
# intro = "Here is important information about your account security."

# first_name = 'Joffrey'
# greeting = 'Hello'

# # BEGIN (write your solution here)
# info = "Here is important information about your account security."
# intro = "We couldn't verify your mother's maiden name." 
# print (greeting + ', ' + first_name + '!')
# print (info + '\n' + intro)
# # END

################################################## 22. Python: Именование переменных
# В именовании переменных можно выделить три основных подхода, которые иногда комбинируют друг с другом. 
# Все эти подходы проявляют себя, когда имя переменной состоит из нескольких слов:

# kebab-case — составные части переменной разделяются дефисом (my-super-var)
# snake_case — для разделения используется подчеркивание (my_super_var)
# CamelCase — каждое слово в переменной пишется с заглавной буквы (MySuperVar)
# Переменные в Python именуются в стиле snake_case: слова записываются строчными буквами и разделяются символом подчеркивания _. 
# Чтобы разобраться подробнее, можете изучить раздел «Как называть переменные» в стандарте PEP8.
# Создайте две переменные с именами «первое число» и «второе число» на английском языке используя snake_case. 
# Запишите в первую переменную число 20, во вторую — -100. Выведите на экран произведение чисел, 
# записанных в получившиеся переменные.
# first_number = 20
# second_number = -100
# print (first_number * second_number)

################################################## 23. Python: Магические числа
# Чтобы предотвратить проблему, нужно создавать переменные с правильными именами. Так все встанет на свои места:

# dollars_per_euro = 1.25
# rubles_per_dollar = 60

# euros_count = 1000
# dollars_count = euros_count * dollars_per_euro     # 1250.0
# rubles_count = dollars_count * rubles_per_dollar  # 75000.0

# print(rubles_count)

################################################## 24. Python: Константы
# Константа — способ сохранить информацию и дать ей имя для последующего использования в коде; константы нельзя изменять, 
# в отличие от переменных.
# PI = 3.14
# print(PI)  # => 3.14


################################################## 25. Python: Интерполяция
# Интерполяция — способ получения сложной строки из нескольких простых с использованием специальных шаблонов
# stark = 'Arya'
# # BEGIN (write your solution here)
# send_mess = f'Do you want to eat, {stark}?'
# print (send_mess)
# # END
# first_name = 'Joffrey'
# greeting = 'Hello'

# print(f'{greeting}, {first_name}!')
# # => Hello, Joffrey!

################################################## 26. Python: Извлечение символов из строки
# magic = '\nyou'
# print(magic[1]) # => 'y'
# # Длина строки 9, поэтому последний индекс — это 8
# first_name = 'Alexander'

# print(first_name[8])  # => r

# print(first_name[9])
# IndexError: string index out of range

################################################## 27. Python: Срезы строк
# Срезы для строк — механизм, с помощью которого извлекается подстрока по указанным параметрам.
# str[начальный индекс:конечный индекс]
# # Пара примеров
# value = '01-12-9873'
# # Срез строки это всегда строка,
# # даже если внутри строки было число.
# value[1:2]  # '1'
# value[3:5]  # '12'
# value = 'Hexlet'
# value[3:]  # 'let'
# value[:3]  # 'Hex'
# value = 'Hexlet'
# # Правая граница отрицательная. Считаем -1 от конца строки
# value[3:-1]  # 'le'
# # Левая граница отрицательная. Считаем -5 от конца строки
# value[-5:3]  # 'ex'
# У срезов два обязательных параметра, но иногда используется и третий.
# У срезов есть третий необязательный параметр — шаг извлечения. По умолчанию он равен единице, но мы можем его изменить:
# value = 'Hexlet'
# value[1:5:2]  # el
# # 1:5 это 'exle'
# # шаг 2 это каждый второй, то есть 'e' и 'l'
# Все это можно комбинировать с открытыми границами, то есть без указания начала или конца:
# value = 'Hexlet'
# value[:5:2]  # 'Hxe'
# value[1::2]  # 'elt'
# Если используется отрицательный шаг, и элементы среза извлекаются в обратном порядке — тогда и границы среза тоже 
# нужно указывать в обратном порядке. Первой указывается правая граница среза, второй — левая:
# value = 'Hexlet'
# # Символ с индексом 1 не будет включен в подстроку
# value[4:1:-1]  # 'elx'
# Решение учителя:
# value = 'Hexlet'
# # BEGIN
# print(value[2:5])
# # END
# Ваше решение:
# value = 'Hexlet'
# # BEGIN (write your solution here)
# start = 2
# end = 5
# print (value[start:end]) # 'xle'
# # END

################################################## 28. Multi-line строки
# text = 'Пример текста,\nсостоящего из\nнескольких строк'
# # BEGIN (write your solution here)
# text = '''Lannister, Targaryen, Baratheon, Stark, Tyrell...
# they're all just spokes on a wheel.
# This one's on top, then that one's on top, and on and on it spins,
# crushing those on the ground.
# '''
# # END
# print(text)

################################################## 29. Типы данных
# Тип данных — множество данных в коде (разновидность информации). Тип определяет, что можно делать с элементами конкретного множества. 
# Например, целые числа, рациональные числа, строки — это разные типы данных.
# Примитивные типы данных — простые типы, встроенные в сам язык программирования.
# Строка (string) — тип данных, описывающий набор символов (иными словами — текст) например, 'text' или "text"

################################################## 30. Сильная (или Строгая) типизация
# print(1 + '7')  # TypeError: unsupported operand type(s)...
# Python не разрешит сложить число 1 и строку '7', потому что это значения разных типов. 
# Нужно сначала либо сделать строку числом, либо число строкой. 
# Такое педантичное отношение к совместимости типов называется строгой типизацией или сильной типизацией. 
# Python — язык со строгой типизацией.

################################################## 31. Неизменяемость примитивных типов
# Представим, что нам нужно изменить символ в строке. Вот, что из этого выйдет:
# first_name = 'Alexander'
# first_name[0] = 'B'
# # Ошибка: TypeError: 'str' object does not support item assignment
# Такое происходит из-за неизменяемости примитивных типов в Python — язык не дает никакой физической возможности поменять строку. 
# Неизменяемость примитивных типов важна по многим причинам. Ключевая причина — производительность.
# Есть большая разница между изменением значения переменной и изменением самого значения. 
# Примитивные типы в Python поменять нельзя, а составные — можно. Также можно без проблем заменить значение переменной.
# Задание
# Вам даны три переменные с фамилиями разных людей. Составьте и выведите на экран слово из символов в таком порядке:
# Третий символ из первой строки
# Второй символ из второй строки
# Четвертый символ из третьей строки
# Пятый символ из второй строки
# Третий символ из второй строки
# Попробуйте использовать интерполяцию: внутри фигурных скобок можно помещать не только целые переменные, 
# но и отдельные символы с помощью квадратных скобок.
# one = 'Naharis'
# #      0123456  
# two = 'Mormont'
# #      0123456
# three = 'Sand'
# #        0123456
# # BEGIN (write your solution here)

# # Третий символ из первой строки
# # Второй символ из второй строки
# # Четвертый символ из третьей строки
# # Пятый символ из второй строки
# # Третий символ из второй строки
# s1 = 2
# s2 = 1
# s3 = 3
# s4 = 4
# s5 = 2
# print (f'{one[s1]}{two[s2]}{three[s3]}{two[s4]}{two[s5]}' )  => 'hodor'

################################################## 32. Явное преобразование типов
# str станет int
# number = int('345')
# print(number)  # => 345
# int() — это функция, в которую передается значение, чтобы его преобразовать. 
# Функция ведет себя подобно арифметическим операциям, но делает особые действия. Вот еще несколько примеров:
# Точно так же можно преобразовать данные в строки str() и число с плавающей точкой float():
# value = str(10)
# print(value)  # '10'

# value2 = str(True)
# print(value2)  # 'True'

# value3 = float(5)
# print(value3)  # 5.0

# Решение учителя:
# value = 2.9

# # BEGIN
# int_value = int(value)
# str_value = str(int_value)
# print(str_value + ' times')
# # END
# Ваше решение:
# value = 2.9

# # BEGIN (write your solution here)

# # Выведите на экран строку 2 times, полученную из числа 2.9 (хранится в переменной value) и 
# # строки times, используя преобразования типов и конкатенацию. 
# # Для этого нужно выполнить два преобразования: сначала в целое число, а затем в строку
# print (f'{str(int(value))} times')
# END

################################################## 33. Функции и их вызов
# Функция — операция, способная принимать данные и возвращать результат; функция вызывается так: foo().
# Аргумент — информация, которую функция получает при вызове. 
# Например, foo(42) — передача аргумента 42 функции foo()
# Параметры или аргументы — это информация, которую функция получает при вызове. На основе этой информации 
# функция обычно вычисляет и выдает результат.

# Мы создали переменную result и указали интерпретатору конкретное действие: надо записать в нее результат, 
# который возвращается функцией len() при ее вызове. В этом смысле функции подобны операциям — они всегда 
# возвращают результат своей работы. Запись len('Hello!') означает, что вызывается функция с именем len, 
# в которую передали параметр 'Hello!'. Функция len() считает длину той строки, которую ей передали.
# Решение учителя:
# company1 = 'Apple'
# company2 = 'Samsung'

# # BEGIN
# company1_len = len(company1)
# company2_len = len(company2)

# print(company1_len + company2_len)
# # END
# Ваше решение:
# company1 = 'Apple'
# company2 = 'Samsung'

# # BEGIN (write your solution here)
# # В коде программы определены две переменные, 
# # cодержащие имена компаний. Посчитайте их общую длину 
# # в символах и выведите ее на экран.
# common_len = len(company1) + len (company2)
# print (common_len)

################################################## 34. Сигнатура функции
# Сигнатура функции — формальное описание типов аргументов и типа возвращаемого значения функции.
# Задание
# Теперь ваша очередь посмотреть на сигнатуру функции в документации и разобраться, как её использовать.
# В Python есть функция hex(). Изучите её сигнатуру на странице документации.
# Напишите программу, которая выведет на экран результат работы функции hex() с переменной number в качестве параметра.
# number = 255
# # BEGIN (write your solution here)
# print (hex(number))
# # END

################################################## 35. Аргументы по умолчанию
# Параметр по умолчанию — необязательный параметр функции
# Рассмотрим функцию round(), которая округляет переданное ей число:

# result = round(10.25, 0)  # 10.0
# Мы передали в нее два параметра:

# Число, которое нужно округлить
# Точность округления
# 0 означает, что округление будет до целого значения. Чаще всего нужно округлять именно до целого числа, 
# а не до десятых. Поэтому создатели функции round сделали второй параметр необязательным и задали ему внутри 
# функции значение по умолчанию 0. Значит, можно не указывать второй параметр, а результат будет тем же:

# result = round(10.25)  # 10.0
# А если нужна другая точность, то можно передать параметр:

# # округление до одного знака после запятой
# result = round(10.25, 1)  # 10.2
# Если функция в Python принимает необязательные аргументы, то они всегда стоят после обязательных. 
# Их количество может быть любым. Это зависит от самой функции, но они всегда идут рядом и в конце списка аргументов.

################################################## 36. Вызов функции — выражение
# Выражение — последовательность действий над данными, приводящая к каком-то результату, который можно использовать.
# Мы знаем, что функции возвращают результат — значит, они выражения. Из этого автоматически следует много интересного. 
# Например, мы можем использовать вызов функции прямо в математических операциях. Вот как можно получить индекс 
# последнего символа в слове:
# name = 'python'
# # Индексы начинаются с нуля
# # Вызов функции и вычитание вместе!
# last_index = len(name) - 1
# print(last_index)  # => 5
# В этом коде нет нового синтаксиса. Мы всего лишь соединили уже известные части, опираясь на их природу. Можно пойти еще дальше:

# print(len(name) - 1)  # => 5
# Все это справедливо для любых функций, например строковых:

# name = 'python'
# # Используется интерполяция
# print(f'Последний символ: {name[len(name) - 1]}')# 'Последний символ: n'

# Решение учителя:
# text = 'Never forget what you are, for surely the world will not'

# # BEGIN
# result = f'First: {text[0]}\nLast: {text[-1]}'
# print(result)
# # END
# Ваше решение:
# text = 'Never forget what you are, for surely the world will not'

# # BEGIN (write your solution here)

# # Выведите на экран первую и последнюю буквы предложения, 
# # записанного в переменную text, в следующем формате:
# # First: N
# # Last: t
# print_end = f'''First: {text[0]}
# Last: {text[-1]}'''
# print (print_end)
# result # 'First: N\nLast: t'
# # END


################################################## 37. Функции с переменным числом параметров
# Аргумент по умолчанию — необязательный аргумент функции.
# У некоторых функций есть особенность — они принимают переменное число параметров. И мы говорим не о значениях по умолчанию. 
# Посмотрите на этот пример:
# max(1, 10, 3)  # 10
# В примере выше функция max() находит максимальное значение среди переданных параметров. Чтобы узнать, сколько 
# параметров можно передавать на вход, нужно изучить документацию этой функции. Там мы увидим такую конструкцию:

# max(arg1, arg2, *args[, key])
# Это значит, что max() принимает на вход два параметра и больше:
# max(1, -3, 2, 3, 2)  # 3
# Если функция найдет несколько параметров с максимальным значением, значит, она вернет самый первый из них.


################################################## 38. Детерминированность
# Детерминированная функция возвращает один и тот же результат для одинаковых входных параметров. 
# Например, детерминированной можно назвать функцию, которая считает количество символов:
# len('hexlet')  # 6
# len('hexlet')  # 6
# len('wow')  # 3
# len('wow')  # 3
# Посмотрим и обратный случай — недетерминированные функции. Например, к этой категории относится функция, 
# которая возвращает случайное число: у одного и того же входа мы получим всегда разный результат. 
# Если хотя бы один из миллиона вызовов функция вернет другой результат, она считается недетерминированной. 
# Это работает и в том случае, если параметры не принимаются:
# # Синтаксис импортов будет изучаться позже на Хекслете
# from random import random
# # Функция, которая возвращает случайное число
# random()  # 0.09856613113197676

# Функция random() возвращает случайное число от 0 до 1 с большим количеством знаков после запятой. 
# Реализуйте код, который выводит на экран случайное целое число в диапазоне от 0 до 10. 
# Для этой задачи вам понадобится функция random() и функция round(), которая округляет переданное ей значение
# Решение учителя:
# # imports are studied on Hexlet
# from random import random

# # BEGIN
# print(round(random() * 10))
# # END
# Ваше решение:
# # imports are studied on Hexlet
# from random import random

# # BEGIN (write your solution here)
# print (round(random() * 10))
# # END


################################################## 39. Стандартная библиотека
# Стандартная библиотека — набор полезных функций, входящий в комплект поставки языка программирования.
# Вот советы, которые помогут повысить уровень профессионализма:

# Всегда отслеживайте, с каким типом данных вы работаете. Так вы найдете необходимую функцию в соответствующем 
# разделе документации. Например, для работы со строками нужно изучать строковые функции
# Периодически открывайте раздел со стандартными функциями по вашей тематике, изучайте сигнатуры и способы использования.
# Чаще читайте чужой код на GitHub. Особенное внимание обращайте на код библиотек, которые используете
# Если следовать этим советам и внимательно относиться к деталям, то уже скоро вы заметите, как развиваетесь и растете как профессионал.
# Задание
# Функция type() позволяет определить тип передаваемого аргумента. Название типа возвращается в виде строки. 
# Например, вызов type(10) вернёт строку <class 'int'> (int, это сокращение от integer — целое число).
# print(type('wow')) # <class 'str'>
# Выведите на экран тип значения переменной motto.
# Решение учителя:
# motto = 'Family, Duty, Honor'

# # BEGIN
# print(type(motto))
# # END
# Ваше решение:
# motto = 'Family, Duty, Honor'

# # BEGIN (write your solution here)
# print(type(motto)) # "<class 'str'>"
# # END

################################################## 40. Объекты
# Объектно-ориентированный код строится на объединении данных и функций в одну сущность — объект. 
# Данные в таком случае называются атрибутами, а функции — методами.
# У данных, которыми мы оперируем в программах, есть важные атрибуты. В Python они встроены прямо в язык. 
# Еще у данных есть методы — функции внутри свойств. Свойства и методы — такие же выражения, как переменные 
# или вызовы функции. Все это можно по-разному комбинировать. В этом уроке изучим их основы.

# В программировании мы оперируем данными, создаем числа и строки, выполняем над ними различные операции и используем полученный результат. 
# Чтобы выполнить операцию, мы применяем либо операторы, либо функции:

# # Сложение с помощью оператора +
# 1 + 3 # 4

# # Подсчет длины с помощью функции len()
# name = 'Hexlet'
# len(name)  # 6
# В примере выше есть четкое разделение: данные отдельно, функции отдельно. Но это не единственный способ организации кода.  
# Python наравне с таким разделением, используется и другой подход — объектно-ориентированный (ОО).
# Так это выглядит:

# name = 'Hexlet'
# # Метод upper()
# upper_name = name.upper()
# print(upper_name)  # => 'HEXLET'
# Строки в Python — это объекты. В примере выше мы вызываем метод, то есть функцию, которая связана со строкой. 
# Вызов происходит через точку, которая идет сразу за именем переменной. В остальном методы работают как обычные функции.


################################################## 41. Неизменяемость
# Метод — это функция или процедура, принадлежащая какому-то классу или объекту.
# Допустим, у нас есть такой вызов:

# name = 'Tirion'
# print(name.upper())  # => TIRION
# # Что напечатает на экран этот вызов?
# print(name)  # => ?
# Вызов метода .upper() возвращает новое значение, в котором все буквы преобразованы в верхний регистр, 
# но он не меняет исходную строку. Поэтому внутри переменной окажется старое значение: 'Tirion'. 
# Эта логика справедлива для методов всех примитивных типов.

# Вместо того чтобы изменять значения, можно заменить значение. Для этого понадобятся переменные:

# name = 'Tirion'
# name = name.upper()
# print(name)  # => TIRION


################################################## 42. Методы как выражения
# Методы — такие же выражения, как переменные или вызовы функции, значит, их можно по-разному комбинировать.
# Метод — это функция или процедура, принадлежащая какому-то классу или объекту.
# text = 'Never forget what you are, for surely the world will not'

# # BEGIN (write your solution here)
# # Найдите символы N и , (запятая) внутри текста в переменной text. 
# # Выведите на экран их индексы. Ожидаемый тестами вывод:

# # Index Of N: 0
# # Index Of ,: 25
# # Ваша задача найти эти индексы в строке с помощью метода .find() и вставить в print(), 
# # не используя промежуточные переменные. 
# # Это упражнение можно решить как при помощи интерполяции, 
# # так и при помощи конкатенации. Если вы используете конкатенацию, 
# # то полученный результат необходимо 
# # привести к строковому типу. Для разбиения вывода на две строки, 
# # вам может понадобится \n.
# print (f'Index Of N: {text.find("N")}\nIndex Of ,: {text.find(",")}')
# #print (f"Index Of N: {text.find('N')}\nIndex Of ,: {text.find(',')}")

# # END
# #'Index Of N: 0\nIndex Of ,: 25'

################################################## 43. Цепочка вызовов
# как комбинировать различные подходы, когда пишем код, а также разберем типичные ошибки новичков.
# У нас есть следующий код:
# name = 'Tirion'
# print(name.upper().lower())  # => `tirion`
# Чтобы понять, как работает этот код, нужно разбить цепочку на отдельные операции:

# name = 'Tirion'
# upper_name = name.upper()  # 'TIRION'
# print(upper_name.lower())  # 'tirion'
# Первый и второй примеры эквивалентны. Мы можем выполнять операции последовательно с промежуточным созданием переменных, 
# а можем строить непрерывную цепочку из атрибутов и методов. В цепочках вычисления всегда идут слева направо.

# Еще один пример для закрепления:

# name = 'Tirion'
# print(name.replace('Ti', 'Ki').lower())  # => ?

# text = 'When \t\n you play a \t\n game of thrones you win or you die.'

# # BEGIN (write your solution here)
# # С помощью среза строк получите часть предложения, записанного в переменную text, 
# # c 5 по 15 символы включительно. Полученную подстроку обработайте методом .strip() 
# # и выведите на экран длину итоговой подстроки. 
# # Выполните эти операции подряд в цепочке без создания промежуточных переменных.
# print(len(text[4:15].strip()))
# # END


################################################## 44. Создание (определение) функций
# С помощью определения собственных функций писать и поддерживать программы проще. 
# Они позволяют объединять составные операции в одну.
# Допустим, мы хотим отправить письма на сайте — это достаточно сложный процесс, который включает 
# взаимодействие с внешними системами. Но если определить функцию, вся сложность скроется за одной простой функцией:

# # Гипотетический пример
# # Место откуда берется функция
# from emails import send

# email = 'support@hexlet.io'
# title = 'Помогите'
# body = 'Я написал историю успеха, как я могу получить скидку?'

# # Один маленький вызов — много логики внутри
# send(email, title, body)
# Внутри себя этот вызов выполняет много логики: соединяется с почтовым сервером, формирует правильный 
# запрос на основе заголовка и тела сообщения, а затем все отправляет, не забыв закрыть соединение.

# Описание, которое находится ниже имени функции с отступом, называется телом функции. 
# Внутри тела можно описывать любой код. Это как небольшая самостоятельная программа — набор произвольных инструкций.

# Тело выполняется в тот момент, когда запускается функция. При этом каждый вызов функции запускает тело независимо от других вызовов.

# Тело функции может быть пустым, тогда внутри него используется ключевое слово pass:

# # Минимальное определение функции
# def noop():
#     pass
# noop()

# def print_motto():
#     text_print = 'Winter is coming'
#     print (text_print)

# print_motto()

################################################## 45. Возврат значений
# def greeting():
#     return 'Hello, Hexlet!'
# return — это инструкция. Она берет записанное справа выражение и отдает его тому коду, который вызвал метод. 
# Здесь выполнение функции завершается.
# Любой код после return не выполняется:

# def greeting_with_code_after_return():
#     return 'Hello, Hexlet!'
#     print('Я никогда не выполнюсь')
# Даже если функция возвращает данные, это не ограничивает ее в том, что она печатает. Кроме возврата данных мы можем и печатать:

# def greeting_with_return_and_printing():
#     print('Я появлюсь в консоли')
#     return 'Hello, Hexlet!'


# # И напечатает текст на экран, и вернет значение
# message = greeting_with_return_and_printing()
# Возвращать можно не только конкретное значение. Так как return работает с выражениями, то справа от него может быть что угодно. Здесь нужно руководствоваться принципами читаемости кода:

# def greeting():
#     message = 'Hello, Hexlet!'
#     return message
# Здесь мы не возвращаем переменную. Возвращается всегда значение, которое находится в этой переменной. Ниже пример с вычислениями:

# def double_five():
#     # или return 5 + 5
#     result = 5 + 5
#     return result
# Определить функцию мало. Еще важно, чтобы она была полезна, и результатом можно было воспользоваться. А теперь подумайте, что вернет вызов, определенной ниже функции run()?

# # Определение
# def run():
#     return 5
#     return 10


# # Что будет выведено на экран?
# print(run())

################################################## 46. Параметры функций
# Функции могут не только возвращать значения, но и принимать параметры. 
# В этом уроке мы научимся создавать такие функции.
# Напомним, что с параметрами функций мы уже сталкивались:
# Многие функции работают одновременно с несколькими параметрами. Например, чтобы округлить числа, 
# нужно указать не только само число, но и количество знаков после запятой:

# round(10.23456, 3)  # 10.235
# То же самое относится и к методам. Они могут требовать на вход любое количество параметров, 
# которое им нужно для работы:

# # Первый параметр — что ищем
# # Второй параметр — на что меняем
# 'google'.replace('go', 'mo')  # moogle
# Чтобы создать такие функции и методы, в определении нужно указать необходимое количество параметров 
# через запятую. Еще им нужно дать понятные имена.
# # def truncate(text, length):
#     # BEGIN (write your solution here)
#     # Допишите функцию truncate(), которая обрезает переданную строку до указанного 
#     # количества символов, добавляет в конце троеточие и возвращает получившуюся строку. 
#     # Подобная логика часто используется на сайтах, чтобы отобразить длинный текст 
#     # в сокращенном виде.
#     # Функция принимает два параметра:
#     # Строка, которую нужно обрезать
#     # Число символов, которые нужно оставить
#     text_input=text[0:length]+'...'
#     return (text_input)
#     # END
    
# truncate('hexlet', 2)
# text = 'it works!'
# truncate(text, 4)

################################################## 47. Необязательные параметры функций
# Параметр по умолчанию — необязательный параметр функции
# У значений по умолчанию есть одно ограничение. Они должны идти в самом конце списка параметров. 
# С точки зрения синтаксиса, невозможно создать функцию, у которой после необязательного параметра идет обязательный:
# Такой код завершится с ошибкой
# def f(a=5, b=10, c=100, x):
# # И такой
# def f(a=5, b=10, x, c=100):

# # Этот код сработает
# def f(x, a=5, b=10, c=100):

# # Этот тоже сработает
# def f(x, y, a=5, b=10, c=100):

# Задание
# Реализуйте функцию get_hidden_card(), который принимает на вход номер кредитки (состоящий из 16 цифр) в 
# виде строки и возвращает его скрытую версию, которая может использоваться на сайте для отображения. 
# Если исходная карта имела номер 2034399002125581, то скрытая версия выглядит так ****5581. 
# Другими словами, функция заменяет первые 12 символов, на звездочки. 
# Количество звездочек регулируется вторым, необязательным, параметром. Значение по умолчанию — 4.

# def get_hidden_card(card_number, hidden_num = 4 ):
#     if len(card_number) != 16:
#         raise ValueError('Количество цифр должно быть 16')
#     card_number = '*' * hidden_num + card_number[12:]
#     return card_number

################################################## 48. Именованные аргументы
# Аргументы — это данные, которые передаются в вызов функции. Они бывают двух типов:
# Первый тип — позиционные аргументы. Они передаются в том же порядке, в котором определены параметры функции:
# # (text, length)
# truncate('My Text', 3)
# Второй тип — именованные аргументы. Они передаются не просто как значения, а как пара «имя=значение». 
# Поэтому их можно передавать в любом порядке:
# # Аргументы переданы в другом порядке
# truncate(length=3, text='My Text')
# Если внимательно посмотреть на два примера выше, то можно понять, что это две одинаковые функции.
# Теперь разберемся, в каких случаях нужно применять эти типы аргументов.
# Выбор типа параметра зависит от того, кто вызывает функцию.
# Есть две причины использовать именованные аргументы:
# Они повышают читаемость, так как сразу видно имена
# Можно не указывать все промежуточные параметры, которые нам сейчас не нужны
# Последнее полезно, если у функции много необязательных параметров. Посмотрим на примере:
# def f(a=1, b=2, c=None, d=4):
#     print(a, b, c, d)
# # Нужно передать только d, но приходится передавать все
# f(1, 2, 3, 8)
# # Именованные аргументы позволяют передавать только d
# # Для остальных аргументов используются значения по умолчанию
# f(d=8)
# Именованные аргументы можно передавать одновременно с позиционными. Тогда позиционные должны идти в самом начале:

# # Передаем только a (позиционно) и d (как именованный)
# f(3, d=3)
# Задание
# Реализуйте функцию trim_and_repeat(), которая принимает три параметра: строку, offset — число символов, на которое нужно обрезать строку слева и repetitions — количество обрезанных строк, которые нужно вывести. Функция обрезает строку и повторяет ее столько раз, чтобы общее количество обрезанных строк равнялось repetitions. Функция должна записать результат в одну строку и вернуть его.
# Число символов для среза по умолчанию равно 0, а повторений — 1.

# text = 'python'
# print(trim_and_repeat(text, offset=3, repetitions=2)) # => honhon
# print(trim_and_repeat(text, repetitions=3)) # => pythonpythonpython
# print(trim_and_repeat(text)) # => python
# def trim_and_repeat(text, offset = 0, repetitions = 1):
#     temp = len(text)
#     text = text[0+offset:temp] * repetitions
#     return text
    
# text = 'python'
# print(trim_and_repeat(text, offset=3, repetitions=2))
# print(trim_and_repeat(text, repetitions=3))
# print(trim_and_repeat(text))

################################################## 49. Логический тип
# Логический тип (bool) — тип данных с двумя возможными значениями: True (истина) и False (ложь).
# Языки программирования адаптировали все математические операции сравнения в неизменном виде, кроме операторов равенства и неравенства. В математике для этого используется обычное равно =, но в программировании такое встречается редко.
# Во многих языках символ = используется, чтобы присвоить переменным значения. Поэтому в Python сравнивают с помощью ==.
# Список операций сравнения:
# < — меньше
# <= — меньше или равно
# > — больше
# >= — больше или равно
# == — равно
# != — не равно
# Эти операции применяются не только к числам. Например, с помощью оператора равенства можно сравнить строки: password == text — это сравнение идентичности строк, которые записаны в разных переменных.
# Логическая операция типа 5 > 4 или password == text — это выражение. Его результат — специальное значение True («истина») или False («ложь»). 
# Это новый для нас тип данных — bool.
# result = 5 > 4
# print(result)  # => True
# print('one' != 'one')  # => False
# Наряду со строками (str) и целыми и рациональными числами, тип bool (булев) — это один из примитивных типов данных в Python.
# Попробуем написать простую функцию, которая принимает на вход возраст ребенка и определяет, младенец ли он. Младенцами считаются дети до года:
# def is_infant(age):
#     return age < 1
# print(is_infant(3))  # => False
# Задание
# Напишите функцию is_pensioner(), которая принимает возраст в качестве 
# единственного аргумента и проверяет, является ли этот возраст пенсионным. 
# Пенсионным считается возраст 60 лет и больше.
# def is_pensioner(age):
#     return age >= 60
# # Примеры вызова:

# is_pensioner(75) # True
# is_pensioner(18) # False

################################################## 50. Предикаты
# Предикат — выражение, отвечающее на вопрос «да» или «нет» с помощью типа bool.
# Функция is_infant() — это функция-предикат или функция-вопрос. Предикат отвечает на утвердительный вопрос «да» или «нет», возвращая значение типа bool. Предикаты во всех языках принято именовать особым образом для простоты анализа. В Python предикаты начинаются с префикса is или has:
# is_infant() — «младенец ли?»
# has_children() — «есть ли дети?»
# is_empty() — «пустой ли?»
# has_errors() — «есть ли ошибки?»
# Функция считается предикатом, если она возвращает булевы значения True или False.
# Напишем еще одну функцию-предикат. Она принимает строку и проверяет, является ли она словом 'Castle':
# def is_castle(string):
#     return string == 'Castle'
# print(is_castle('Sea')) # False
# Задание
# # Напишите функцию is_mister(), которая принимает строку и проверяет, 
# # является ли она словом 'Mister'.
# def is_mister(string):
#     return string == 'Mister'
# is_mister('Mister') # True
# is_mister('Missis') # False

################################################## 51. Комбинирование операций и функций
# Логические операции — это выражения, значит, их можно комбинировать с другими выражениями.
# Выражение — последовательность действий над данными, приводящая к каком-то результату, который можно использовать
# Теперь вы знаете, что операции сравнения применяются в программировании наравне с арифметическими. 
# Но помните, что равенство обозначается ==. Так вы не спутаете эту операцию с присваиванием значения переменной.
# Решение учителя:
# def is_international_phone(phone):
#     return phone[0] == '+'
# Ваше решение:
# # Реализуйте функцию is_international_phone(), которая проверяет формат 
# # указанного телефона. Если телефон начинается с +, значит это международный формат.
# def is_international_phone(string):
#     first_number = string[0]
#     return first_number == '+'
# is_international_phone('89602223423')  # False
# is_international_phone('+79602223423') # True


################################################### 52. Логические операторы
# И and ИЛИ or

# Решение учителя:
# def is_leap_year(year):
#     return year % 400 == 0 or (year % 4 == 0 and year % 100 != 0)
# Ваше решение:
# # Реализуйте метод is_leap_year(), который определяет является ли год високосным или нет. 
# # Год будет високосным, если он кратен (то есть делится без остатка) 400 или он одновременно кратен 4 и не кратен 100. 
# # Как видите, в определении уже заложена вся необходимая логика, осталось только переложить её на код:
# # is_leap_year(2018) # false
# # is_leap_year(2017) # false
# # is_leap_year(2016) # true
# # Кратность можно проверять так:

# # # % - возвращает остаток от деления левого операнда на правый
# # # Проверяем что number кратен 10
# # number % 10 == 0

# # # Проверяем что number не кратен 10
# # number % 10 != 0

# def is_leap_year(input_years):
#      return (input_years % 400 == 0) or (input_years % 4 == 0) and (input_years % 100 != 0)

# print(is_leap_year(2018))
# print(is_leap_year(2017))
# print(is_leap_year(2016))
# # print(is_leap_year(2018))
# # print(is_leap_year(1900))

################################################### 53. Отрицание
# Реализуйте функцию is_palindrome(), которая определяет, является ли слово палиндромом или нет. 
# Палиндром - это слово, которое читается одинаково в обоих направлениях. Слова в функцию могут быть переданы в любом регистре, 
# поэтому сначала нужно привести слово к нижнему регистру: word.lower().

# is_palindrome('шалаш') # true
# is_palindrome('хекслет') # false
# is_palindrome('Довод') # true
# is_palindrome('Функция') # false
# Реализуйте функцию is_not_palindrome(), которая проверяет что слово НЕ является палиндромом:

# is_not_palindrome('шалаш') # false
# is_not_palindrome('Ага') # false
# is_not_palindrome('хекслет') # true
# Для этого, вызовите функцию is_palindrome() внутри is_not_palindrome() и примените отрицание.


# Решение учителя:
# def is_palindrome(word):
#     lower_word = word.lower()
#     return lower_word == lower_word[::-1]


# def is_not_palindrome(word):
#     return not is_palindrome(word)
# Ваше решение:
# def is_not_palindrome(word):
#     def is_palindrome(word):
#         if len(word) == 0:
#             return ('Слово нулевой длины')
#         else:
#             word = word.lower()
#             word_1 = word[::-1]
#             return (word == word_1)

#     return (not is_palindrome(word))

# is_not_palindrome('шалаш') # false
# is_not_palindrome('Ага') # false
# is_not_palindrome('хекслет') # true




################################################### 54. Результат логических выражений



################################################### 55. Условная конструкция (if)


################################################### 56. Условная конструкция else


################################################### 57. Конструкция else + if = elif



################################################### 58. Тернарный оператор



################################################### 59. Оператор Match



################################################### 60. Цикл While



################################################### 61. Агрегация данных (Числа)



################################################### 62. Агрегация данных (Строки)



################################################### 63. Обход строк



################################################### 64. Условия внутри тела цикла



################################################### 65. Формирование строк в циклах



################################################### 66. Пограничные случаи



################################################### 67. Синтаксический сахар




################################################### 68. Возврат из циклов



################################################### 69. Цикл For